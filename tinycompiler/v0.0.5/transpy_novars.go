package main

import (
	"fmt"
)

func transnovars(n Function) string {
	funname := n.name
	funscope := n.deco["scope"].(int)
	funlabel := n.deco["label"].(string)
	nscopes := n.deco["scopeCnt"].(int)

	var allocvars string
	if len(n.vars) > 0 {
		allocvars = fmt.Sprintf("stack.append( None ) # %s", n.vars[0].name)
		for _, va := range n.vars[1:] {
			allocvars += "\n" + fmt.Sprintf("stack.append( None ) # %s", va.name)
		}
	} else {
		allocvars = "pass"
	}

	return funnovars(n) + "\neax, ebx = None, None\n" +
		fmt.Sprintf("display = [ 65536 ]*%d\n", nscopes) + // 65536 is just a big number to increase chances of "out of range" error
		"stack = []\n" + // while accessing the stack in a code generated by a bugged transpiler
		fmt.Sprintf("display[%d] = len(stack) # frame pointer for fun %s\n", funscope, funname) +
		allocvars + "\n" + fmt.Sprintf("%s()\n", funlabel)
}

func funnovars(n Function) string {
	var nestedfun string
	if len(n.fun) > 0 {
		nestedfun = funnovars(n.fun[0])
		for _, f := range n.fun[1:] {
			nestedfun += funnovars(f)
		}
	}

	var funbody string
	if len(n.body) > 0 {
		funbody = statnovars(n.body[0])
		for _, s := range n.body[1:] {
			funbody += statnovars(s)
		}
	}

	return fmt.Sprintf("def %s():\n", n.deco["label"]) + indent([]string{"global eax, ebx, stack, display\n", nestedfun + "\n", funbody})
}

func statnovars(n Statement) string {
	switch e := n.(type) {
	case Print:
		var newline string
		if e.newline {
			newline = "'\\n'"
		} else {
			newline = "''"
		}
		return fmt.Sprintf("%sprint(eax, end=%s)\n", exprnovars(e.expr), newline)
	case Return:
		var expr string
		if e.expr != nil {
			expr = exprnovars(e.expr)
		}
		return fmt.Sprintf("%sreturn eax\n", expr)
	case Assign:
		return fmt.Sprintf("%sstack[display[%d]+%d] = eax # %s\n", exprnovars(e.expr), e.deco["scope"].(int), e.deco["offset"].(int), e.name)
	case FunCall:
		return exprnovars(e)
	case While: // note the exprnovars(n.expr) at the end of the loop body, we need to update eax
		body := []string{}
		for _, s := range e.body {
			body = append(body, statnovars(s))
		}
		ss := []string{}
		if len(body) == 0 {
			ss = append(ss, "pass\n")
		} else {
			ss = body
		}
		ss = append(ss, fmt.Sprintf("%s\n", exprnovars(e.expr)))
		return fmt.Sprintf("%swhile eax:\n%s", exprnovars(e.expr), indent(ss))
	case IfThenElse:
		ibody := []string{}
		for _, s := range e.ibody {
			ibody = append(ibody, statnovars(s))
		}
		ebody := []string{}
		for _, s := range e.ebody {
			ebody = append(ebody, statnovars(s))
		}
		if len(ibody) == 0 {
			ibody = append(ibody, "pass\n")
		}
		if len(ebody) == 0 {
			ebody = append(ebody, "pass\n")
		}
		return fmt.Sprintf("%sif eax:\n%selse:\n%s", exprnovars(e.expr), indent(ibody), indent(ebody))
	default:
		panic(fmt.Sprint("Unknown statement type", e))
	}
}

// convention: all expressions save their results to eax
func exprnovars(n Expression) string {
	getop := func(eop string) string {
		pyeq := map[string]string{"/": "//", "||": "or", "&&": "and"}
		op, ok := pyeq[eop]
		if ok {
			return op
		} else {
			return eop
		}
	}
	switch e := n.(type) {
	case ArithOp:
		pyop := getop(e.op)
		left := exprnovars(e.left)
		right := exprnovars(e.right)
		return left + "stack.append(eax) # evaluate left argument and stash it\n" +
			right + "ebx = eax # evaluate right arg\n" + "eax = stack.pop() # recall left arg\n" +
			fmt.Sprintf("eax = eax %s ebx # binary operation\n", pyop)
	case LogicOp:
		pyop := getop(e.op)
		left := exprnovars(e.left)
		right := exprnovars(e.right)
		return left + "stack.append(eax) # evaluate left argument and stash it\n" +
			right + "ebx = eax # evaluate right arg\n" + "eax = stack.pop() # recall left arg\n" +
			fmt.Sprintf("eax = eax %s ebx # binary operation\n", pyop)
	case Integer:
		return fmt.Sprintf("eax = %d\n", e.value)
	case Boolean:
		var value string
		if e.value {
			value = "True"
		} else {
			value = "False"
		}
		return fmt.Sprintf("eax = %s\n", value)
	case String:
		return fmt.Sprintf("eax = %q\n", e.value)
	case Var:
		return fmt.Sprintf("eax = stack[display[%d]+%d] # %s\n", e.deco["scope"].(int), e.deco["offset"].(int), e.name)
	case FunCall:
		funname := e.name
		funscope := e.deco["fundeco"].(map[string]any)["scope"].(int)
		funlabel := e.deco["fundeco"].(map[string]any)["label"].(string)
		disphead := len(e.args) + len(e.deco["fundeco"].(map[string]any)["local"].([]string)) + 1
		var allocargs string
		if len(e.args) > 0 {
			allocargs = fmt.Sprintf("%sstack.append(eax)", exprnovars(e.args[0]))
			for _, s := range e.args[1:] {
				allocargs += "\n" + fmt.Sprintf("%sstack.append(eax)", exprnovars(s))
			}
		}

		var allocvars string
		if len(e.deco["fundeco"].(map[string]any)["local"].([]string)) > 0 {
			allocvars = fmt.Sprintf("stack.append( None ) # %s", e.deco["fundeco"].(map[string]any)["local"].([]string)[0])
			for _, v := range e.deco["fundeco"].(map[string]any)["local"].([]string)[1:] {
				allocvars += "\n" + fmt.Sprintf("stack.append( None ) # %s", v)
			}
		} else {
			allocvars = "pass"
		}

		var freemem string
		if disphead > 1 {
			freemem = fmt.Sprintf("del stack[-%d]", disphead-1)
		} else {
			freemem = "pass"
		}
		return fmt.Sprintf("# prepare %s() call\n", funname) +
			"# evalaute function arguments\n" + allocargs +
			"\n# reserve local variables\n" + allocvars +
			fmt.Sprintf("\nstack.append(display[%d]) # save old frame pointer\n", funscope) +
			fmt.Sprintf("display[%d] = len(stack)-%d # activate new frame pointer\n", funscope, disphead) +
			fmt.Sprintf("eax = %s()\n", funlabel) +
			fmt.Sprintf("display[%d] = stack.pop() # restore old frame pointer\n", funscope) +
			fmt.Sprintf("%s # delete fun args and local vars if any, thus finishing %s() call\n", freemem, funname)
	default:
		panic(fmt.Sprint("Unknown expression type", e))
	}
}
